#第六章 系统调用

操作系统为用户态运行的进程与硬件设备（如CPU、磁盘、打印机等等）进行交互提供了一组接口。在应用程序和硬件之间设置这样一个接口层具有很多优点，首先，这使得编程更加容易，把用户从学习硬件设备的低级编程特性中解放出来。其次，极大地提高了系统的安全性，内核在要满足某个请求之前就可以在接口级检查这种请求的正确性。最后，更重要的是，这些接口使得程序更具有可移植性，因为只要不同操作系统所提供的一组接口相同，那么在这些操作系统之上就可以正确地编译和执行相同的程序。这组接口就是所谓的“系统调用”。

##6.1系统调用与应用编程接口、系统命令以及内核函数之关系

程序员或系统管理员并非直接与系统调用打交道，在实际使用中程序员调用的是应用编程接口API
(Application Programming Interface)，而管理员使用的则是系统命令。

### 6.1.1 系统调用与API

Linux的应用编程接口（API）遵循了在Unix世界中最流行的应用编程接口标准——POSIX标准。POSIX标准是针对API而不是针对系统调用的。判断一个系统是否与POSIX兼容要看它是否提供了一组合适的应用编程接口，而不管对应的函数是如何实现的。事实上，一些非Unix系统被认为是与POSIX兼容的，是因为它们在用户态的库函数中提供了传统Unix能提供的所有服务。

应用编程接口(API)其实是一个函数定义，
比如常见的read()、malloc()、free（）、abs()函数等，这些函数说明了如何获得一个给定的服务；而系统调用是通过软中断向内核发出一个明确的请求。

API有可能和系统调用的调用形式一致，比如read()函数就和read()系统调用的调用形式一致。但是，情况并不总是这样，这表现在两个方面，一种是几个不同的API其内部实现可能调用了同一个系统调用，例如，Linux的libc库实现了内存分配和释放的函数malloc(
)、calloc( )和free( )，这几个函数的实现都调用了brk(
)系统调用；另一方面,一个API的实现调用了好几个系统调用。更有些API甚至不需要任何系统调用，因为它们不需要内核提供的服务。

从编程者的观点看，API和系统调用之间没有什么差别,二者关注的都是函数名、参数类型及返回代码的含义。然而，从设计者的观点看，这是有差别的，因为系统调用实现是在内核完成的，而用户态的函数是在函数库中实现的。

### 6.1.2 系统调用与系统命令 

系统命令相对应用编程接口更高一层，每个系统命令都是一个可执行程序，比如常用的系统命令ls、hostname等，这些命令的实现调用了系统调用。Linux的系统命令多数位于/bin和/sbin目录下。如果通过strace命令查看它们所调用的系统调用，比如
strace ls或strace hostname，就会发现它们调用了诸如open、brk、fstat、ioctl
等系统调用。

### 6.1.3 系统调用与内核函数

内核函数与普通函数形式上没有什么区别，只不过前者在内核实现，因此要满足一些内核编程的要求[^1]。系统调用是用户进程进入内核的接口层，它本身并非内核函数，但它是由内核函数实现的，进入内核后，不同的系统调用会找到各自对应的内核函数，这些内核函数被称为系统调用的**“服务例程”**。比如系统调用
getpid实际调用的服务例程为sys_getpid()，或者说系统调用getpid()是服务例程sys_getpid()的“**封装例程”**。下面是sys_getpid()在内核的具体实现：

[^1]: 内核编程相比用户编程有一些特点，简单地讲内核程序一般不能引用C库函数；缺少内存保护措施；堆栈有限（因此调用嵌套不能过多）；而且由于调度关系，必须考虑内核执行路径的连续性，不能有长睡眠等行为。

```c
asmlinkage long sys_getpid(void)

{

		return current->pid;

}
```

如果想直接调用服务例程，Linux提供了一个syscall()函数，下面我们举例来对比一下调用系统调用和直接调用内核函数的区别。

```c
/#include<syscall.h>

/#include<unistd.h>

/#include<stdio.h>

/#include<sys/types.h>

int main(void)

{

		long ID1, ID2;

		/*-----------------------------*/

		/* 直接调用内核函数*/

		/*-----------------------------*/

		ID1 = syscall(SYS_getpid);

		printf ("syscall(SYS_getpid)=%ld\n", ID1);

		/*-----------------------------*/

		/* 调用系统调用 */

		/*-----------------------------*/

		ID2 = getpid();

		printf ("getpid()=%ld\n", ID2);

		return(0);

}
```

##6.2 系统调用基本概念

系统调用实质就是函数调用，只是调用的函数是系统函数，处于内核态而已。用户在调用系统调用时会向内核传递一个系统调用号，然后系统调用处理程序通过此号从系统调用表中找到相应的内核函数执行（系统调用服务例程），最后返回。在这个过程中涉及到系统调用号、系统调用表以及系统调用处理程序等概念，本小节将介绍这些基本概念。

### 6.2.1 系统调用号

Linux系统有几百个系统调用，为了唯一的标识每一个系统调用，Linux为每一个系统调用定义了一个唯一的编号，此编号称为系统调用号。它定义在文件linux/arch/x86/include/asm/unistd_32.h中（注意，在不同的版本中，这个头文件的位置稍有不同）：
```c
/#define __NR_restart_syscall 0

/#define __NR_exit 1

/#define __NR_fork 2

/#define __NR_read 3

.……

/#define __NR_fallocate 324
```

由此可见当前系统拥有324个系统调用。系统调用号的另一个目的是作为系统调用表的下标，当用户空间的进程执行一个系统调用的时候，这个系统调用号就被用来指明到底是要执行那个系统调用。系统调用号相当关键，一旦分配好就不能再有任何改变，否则编译好的应用程序就会因为调用到错误的系统调用而导致程序崩溃。

### 6.2.2 系统调用表

为了把系统调用号与相应的服务例程关联起来，内核利用了一个系统调用表，这个表存放在sys_call_table数组中，它是一个函数指针数组，每一个函数指针都指向了其系统调用的封装例程，有NR_syscalls个表项，第n个表项包含系统调用号为n的服务例程的地址。NR_syscalls宏只是对可实现的系统调用最大个数的静态限制，并不表示实际已实现的系统调用个数。这样我们就可以利用系统调用号作为下标，找到其系统调用的封装例程。此表定义在文件linux/arch/x86/kernel/syscall_table_32.S

ENTRY(sys_call_table)

.long sys_restart_syscall /* 0 - old "setup()" system call, used for restarting */

.long sys_exit

.long sys_fork

.long sys_read

.long sys_write

.long sys_open /* 5 */

..……

### 6.2.3系统调用服务例程和系统调用处理程序

每一个系统调用bar()在内核态都有一个对应的内核函数sys_bar()，这个内核函数就是系统调用bar()的实现，也就是说在用户态调用bar()，最终会由内核函数sys_bar()为用户服务，这就是系统调用服务例程。

系统调用既然最终会由相应的内核函数完成，那么为什么不直接调用内核函数呢？这是因为用户空间的程序无法直接执行内核代码，因为内核驻留在受保护的地址空间上，不允许用户进程在内核地址空间上读写。所以，应用程序应该以某种方式通知系统，告诉内核自己需要执行一个系统调用，这种通知内核的机制是靠软中断来实现的，通过引发一个异常来促使系统切换到内核态去执行异常处理程序，此时的异常处理程序就是所谓的系统调用处理程序，下一节会接着介绍此程序。

##6.3系统调用实现

当用户态的进程调用一个系统调用时，CPU从内核态切换到内核态并开始执行一个内核函数。Linux对系统调用的调用必须通过执行int$0x80汇编指令，这条汇编指令产生向量为128的编程异常（参见5.1.3异常及非屏蔽中断）。

因为内核实现了很多不同的系统调用，因此进程必须传递一个系统调用号的参数来识别所需的系统调用；eax寄存器就用做此目的。我们将在本章的“参数传递”一节看到，当调用一个系统调用时通常还要传递另外的参数。

与其他异常处理程序的结构类似，系统调用处理程序执行下列操作：

1.  在内核栈保存大多数寄存器的内容（这个操作对所有的系统调用都是通用的，并用汇编语言编写）。

2.  调用所谓系统调用服务例程的相应的C函数来处理系统调用。

3.  通过syscall_exit_work( )函数从系统调用返回（这个函数用汇编语言编写）。

xyz( )系统调用对应的服务例程的名字通常是sys_xyz(
)。图6.1显示了调用系统调用的应用程序、相应的封装例程、系统调用处理程序及系统调用服务例程之间的关系。箭头表示函数之间的执行流。

<div style="text-align: center">
<img src="media/13.png"/>
</div>

<center>图6.1 调用一个系统调用</center>

### 6.3.1初始化系统调用

内核初始化期间调用trap_init( )函数建立IDT表中128号向量对应的表项，语句如下：

set_system_gate(SYSCALL_VECTOR, &system_call);

其中SYSCALL_VECTOR是一个宏定义，其值为0x80，该调用把下列值装入这个门描述符的相应域（参见第五章“5.2中断描述符表的初始化”一节）：

  段选择子：因为系统调用处理程序属于内核代码,填写内核代码段__KERNEL_CS的段选择子。

偏移量：指向system_call( )系统调用处理程序。

类型：置为15。表示这个异常是一个陷阱，相应的处理程序不禁止可屏蔽中断。

   DPL（描述符特权级）：置为3。这就允许用户态进程调用这个异常处理程序。

### 6.3.2 system_call( )函数

system_call( )函数实现了系统调用处理程序。它首先把系统调用号和这个异常处理程序可以用到的所有CPU寄存器保存到相应的栈中，当然，栈中还有CPU已自动保存的eflags、cs、eip、ss和esp寄存器（参见第五章“异常的硬件处理”一节），也在ds
和es中装入内核数据段的段选择子：

ENTRY(system_call)

pushl %eax

SAVE_ALL

GET_THREAD_INFO(%ebp)

GET_THREAD_INFO()宏把当前进程PCB的地址存放在ebp中；这是通过获得内核栈指针的值并把它取整到8KB的倍数而完成的（参见第三章“3．2．4进程控制块的存放”一节），此宏定义在arch/x86/include/asm/thread_info.h中。然后，对用户态进程传递来的系统调用号进行有效性检查。如果这个号大于或等于NR_syscalls，系统调用处理程序终止：

cmpl $(nr_syscalls), %eax

jae syscall_badsys

如果系统调用号无效，跳转到syscall_badsys处执行，此时就把-ENOSYS值存放在栈中eax[^2]寄存器所在的单元（从当前栈顶开始偏移为24的单元）。然后跳到resume_userspace反回到用户空间。当进程以这种方式恢复它在用户态的执行时，会在eax中发现一个负的返回码。

[^2]: 2
eax寄存器中既存放系统调用号，也存放系统调用的返回值，前者是一个正数，后者是一个负数。

最后， 根据eax中所包含的系统调用号调用对应的特定服务例程：

call *sys_call_table(0， %eax， 4)

因为系统调用表中的每一表项占4个字节，因此首先把eax中的系统调用号乘以4再加上
sys_call_table系统调用表的起始地址，然后从这个地址单元获取指向相应服务例程的指针，内核就找到了要调用的服务例程。

当服务例程执行结束时，system_call( )
从eax获得它的返回值，并把这个返回值存放在栈中，让其位于用户态
eax寄存器曾存放的位置。然后执行syscall_exit代码段，终止系统调用处理程序的执行（参见“5.4.6
从中断返回”一节）。

movl %eax， 24(%esp)

syscall_exit:

...

当进程恢复它在用户态的执行时，就可以在eax中找到系统调用的返回码。

### 6.3.3参数传递

与普通函数类似，系统调用通常也需要输入/输出参数，这些参数可能是实际的值（例如数值），也可能是函数的地址及用户态进程地址空间的变量。因为system_call(
)函数是Linux中所有系统调用唯一的人口点，因此每个系统调用至少有一个参数，即通过eax寄存器传递来的系统调用号。例如，如果一个应用程序调用fork(
)封装例程，在执行int
$0x80汇编指令之前就把eax寄存器置为5。因为这个寄存器的设置是由libc中的封装例程进行的，因此程序员通常并不需要关心系统调用号。

fork(
)系统调用并不需要其他的参数。不过，很多系统调用确实需要由应用程序明确地传递另外的参数。例如，mmap(
)系统调用可能需要多达6个参数（除了系统调用号）。

普通函数的参数传递是通过把参数值写进活动的程序栈（或者用户态栈或者内核态栈）。但是系统调用的参数通常是传递给系统调用处理程序在CPU中的寄存器，然后再拷贝到内核态堆栈。

为什么内核不直接把参数从用户态的栈拷贝到内核态的栈呢？首先，同时操作两个栈是比较复杂的；此外，寄存器的使用使得系统调用处理程序的结构与其他异常处理程序的结构类似。

然而，为了用寄存器传递参数，必须满足两个条件：

1.  每个参数的长度不能超过寄存器的长度，即32位[^3]。

2.  参数的个数不能超过6个（包括eax中传递的系统调用号），因为Intel Pentium寄存器的数量是有限的。

第一个条件总能成立，因为根据POSIX标准，不能存放在32位寄存器中的长参数必须通过指定它们的地址来传递。

对于第二个条件，确实存在多于6个参数的系统调用：在这样的情况下，用一个单独的寄存器指向进程地址空间中这些参数值所在的一个内存区即可。当然，编程者不用关心这个工作区。与任何C调用一样，当调用libc封装例程时，参数被自动地保存在栈中。封装例程将找到合适的方式把参数传递给内核。

存放系统调用参数所用的6个寄存器以递增的顺序为：eax (存放系统调用号)、
ebx、ecx、edx、esi及edi。正如前面看到的那样，system_call(
)使用SAVE_ALL宏把这些寄存器的值保存在内核态堆栈中。因此，当系统调用服务例程转到内核态堆栈时，就会找到system_call(
)的返回地址、紧接着是存放在eax中的参数（即系统调用的第一个参数）、存放在ecx中的参数等等。这种栈结构与普通函数调用的栈结构完全相同，因此，服务例程可以很容易地使用一般C语言构造的参数。

让我们来看一个例子。处理write( )系统调用的sys_write( )服务例程的声明如下：

int sys_write (unsigned int fd， const char * buf，unsigned int count)

C编译器产生一个汇编语言函数，该函数可以在栈顶找到fd、buf和count参数，因为这些参数就位于返回地址的下面。

在少数情况下，系统调用不使用任何参数，但是相应的服务例程也需要知道在发出系统调用之前CPU寄存器的内容。例如，
系统调用fork( )没有参数，但其服务例程do_fork(
)需要知道有关寄存器的值，以便在子进程中使用它们。在这种情况下，一个类型为pt_regs的单独参数允许服务例程访问由SAVE_ALL宏保存在内核态堆栈中的值：

int sys_fork (struct pt_regs regs)

服务例程的返回值必须写到eax寄存器中，这是在执行return
n指令时由C编译程序自动完成的。

### 6.3.4跟踪系统调用的执行

我们可以通过分析getpid系统调用的实际执行过程将上述概念具体化。分析getpid系统调用有两种方法，一种是查看entry.S中的代码细节，阅读相关的源码来分析其运行过程；另外一种是借助一些内核调试工具，动态跟踪执行路径。

假设我们的程序源文件名为getpid.c，程序为：

```c
/#include<syscall.h>

/#include<unistd.h>

/#include<stdio.h>

/#include<sys/types.h>

int main(void) {

long ID;

ID = getpid();

printf ("getpid()=%ld\n", ID);

return(0);

}
```

将其编译成名为getpid的执行文件：“gcc –o getpid
getpid.c”,我们使用KDB来看进入内核后的执行路径（kdb是个内核调试补丁，使用前需要给内核打上该补丁，然后打开调试选项，再重新编译内核）。首先激活KDB
(按下pause键)，设置内核断点 “bp sys_getpid”，退出kdb。然后执行./getpid
。瞬间，进入内核调试状态,执行路径停止在断点sys_getpid处。

1.  在KDB>提示符下，执行bt命令观察堆栈，发现调用的嵌套路径，可以看到sys_getpid是在内核函数system_call中被嵌套调用的。

2.  在KDB>提示符下，执行rd命令查看寄存器中的数值，可以看到eax中存放的是getpid调用号0x00000014(即十进制20)。

3.  在KDB>提示符下，执行ssb（或ss）命令跟踪内核代码执行路径,可以发现sys_getpid执行后，会返回system_call函数，然后接着转入syscall_exit_work例程。

结合用户空间的执行路径，该程序的执行大致可归结为以下几个步骤：

1.  程序调用libc库的封装函数getpid。该封装函数中将系统调用号_NR_getpid（第20个）压入eax寄存器。

2.  调用软中断 int 0x80 进入内核。

3.  在内核中首先执行system_call函数，接着根据系统调用号在系统调用表中查找到对应的系统调用服务例程sys_getpid。

4.  执行sys_getpid服务例程。

5.  执行完毕后，转入syscall_exit_work例程，从系统调用返回。

##6.4 封装例程

上一节讲述了图6.1中当一个系统调用陷入内核时的系统调用处理程序和服务例程。那么libc库中是如何对不同的服务例程进行封装？
Linux的系统调用有200多个，相应的服务例程也这么多，显然，对其一一进行封装是麻烦而不现实的。于是，为了简化对相应的封装例程的声明，Linux定义了从_syscall0到_syscall5的六个宏。之所以定义六个宏，是因为系统调用的参数个数一般不超过六个。

每个宏名字的数字0到5对应着系统调用所用的参数个数(系统调用号除外)。显然，不能用这些宏来为超过5个参数的系统调用或产生非标准返回值的系统调用定义封装例程。

每个宏严格地需要2+2×n个参数，n是系统调用的参数个数。另外两个参数指明系统调用的返回值类型和名字；每一对参数指明相应的系统调用参数的类型和名字。因此，像fork()系统调用的封装例程可以通过如下语句产生：

_syscall0(int，fork)

而write()的封装例程可以通过如下语句生产：

_syscall3(int，write，int，fd，const char *，buf，unsigned int，count)

可以把_syscall3（）这个宏展开成如下的汇编语言代码:

write:

pushl %ebx ; 将ebx 压入栈

movl 8(%esp)， %ebx ;
将一个参数放入ebx（栈中前两个位置存放的是类型和名字，占8个字节）

movl 12(%esp)， %ecx ; 将第二个参数放入ecx

movl 16(%esp)， %edx ; 将第三个参数放入edx

movl $4， %eax ; 把系统调用名对应的系统调用号放入 eax

int $0x80 ; 进行系统调用

cmpl $-126， %eax ; 检查返回码

jbe .L1 ; 如无错跳转

negl %eax ; 求eax的补码

movl %eax， errno ; 将所求的结果放入 errno变量

movl $-1， %eax ; 将eax 置为-1

.L1: popl %ebx ; 从栈中弹出ebx

ret ;返回到调用程序

注意write（）函数的参数是如何在执行0x80指令前被装入到CPU寄存器中。如果eax中的返回值在-1和-125之间，必须被解释为错误码
(内核假定在include/asm-i386/errno.h中定义的最大错误码为125)。如果是这种情况，封装例程在errno中存放-eax的值并返回值-1；否则，返回eax中的值。

通过这种封装，在用户态下调用系统调用就变得简单多了，用户既不需要关心系统调用号，也不需要提供复杂的参数，而且还在不知不觉中让内核为自己提供了服务。这里要说明的是，虽然系统调用一般用在用户程序中，但在内核中同样可以调用这种封装了的系统调用。只不过二者有一些区别而已：

1.  在用户态进行系统调用时，转换到内核态的系统调用处理程序时要进行用户态堆栈到内核态堆栈的切换，即从“int0x80”指令转换到内核态的“system_call”函数时，要保存寄存器ss、esp；而当“iret”指令从“system_call”返回用户态时要取回ss、esp的值。

2.  在内核中进行系统调用时，不用进行堆栈切换，即“int0x80”指令不用切换到内核态“system_call”函数，也不必保存寄存器ss、esp；而当“iret”指令从“system_call”返回，仍然是内核态，所以也不用取回ss、esp的值。

##6. 5 添加新系统调用

系统调用是用户空间和内核空间交互的一种有效手段。除了系统本身提供的系统调用外，我们也可以添加自己的系统调用。

实现一个新的系统调用的第一步是决定它的用途。它要做些什么？每个系统调用都应该有一个明确的用途。在Linux中不提倡采用多用途的（一个系统调用通过传递不同的参数值来选择完成不同的工作）系统调用。

新系统调用的参数、返回值和错误码又该是什么呢？系统调用的界面应该力求简洁，参数尽可能少。系统调用的语义和行为非常关键；因为应用程序依赖它们，所以它们应力求稳定，不作改动。

设计接口的时候要尽量为将来多做考虑。你是不是对函数做了不必要的限制？系统调用被设计的越通用越好。不要假设这个系统调用现在怎么用将来也一定就是这么用。系统调用的目的可能不变，但它的用法却可能改变。这个系统调用可移植吗？要确保不对系统调用做错误的假设，否则将来这个调用就可能会崩溃。记住Unix的格言：“提供机制而不是策略”。

当你写一个系统调用的时候，要时刻注意可移植性和健壮性，不但要考虑当前，还要为将来做打算。基本的Unix系统调用经受住了时间的考验；它们中的很大一部分到现在都还和30年前一样适用和有效。

首先我们通过添加一个简单的系统调用说明其实现步骤，然后说明如何添加一个稍微复杂的系统调用。

系统调用的实现需要调用内核中的函数，因此，内核版本不同，其内核函数名可能稍有差异，假定我们使用的内核版本为2.6.28，x86平台。内核源代码的默认目录为/usr/src/linux。

### 6.5.1 添加系统调用的步骤

我们要添加的这个系统调用没有返回值，也不用传递参数，其名取为mysyscall。其功能是使用户的uid等于0。步骤如下：

####1．添加系统调用号

系统调用号在unistd.h文件中定义。内核中每个系统调用号都以“__NR_”开头，例如，fork的系统调用号为__NR_fork。于是，我们的系统调用号为__NR_mysyscall。具体在arch/x86/include/asm/unistd_32.h和/usr/include/asm
/unistd_32.h文件中添加如下：

…

/#define __NR_dup3 330

/#define __NR_pipe2 331

/#define __NR_inotify_init1 332

/#define __NR_mysyscall 333 /* mysyscall 系统调用号添加在这里*/

添加系统调用号后，系统才能把这个号作为索引去查找系统调用表sys_call_table中的相应表项。

####2．在系统调用表中添加相应表项

如前所述，系统调用处理程序system_call会根据eax中的号到系统调用表sys_call_table中查找相应的系统调用服务例程，因此，我们必须把自己的服务例程sys_mysyscall添加到系统调用表中。系统调用表位于汇编语言arch/x86/kernel/syscall_table_32.S中：

ENTRY(sys_call_table)

.long sys_restart_syscall /* 0 - old "setup()" system call, used for
restarting */

.long sys_exit

.long sys_fork

.long sys_read

…

.long sys_dup3 /* 330 */

.long sys_pipe2

.long sys_inotify_init1

**.long sys_mysyscall /*333 号*/**

到此为止，内核已经能够正确地找到并且调用sys_mysyscall。接下来，就要实现该例程。

####3．实现系统调用服务例程

我们把sys_mysyscall添加在kernel目录下的系统调用文件sys.c中：

```c
asmlinkage int sys_mysyscall(void)

{

		current->uid=0;

}
```

其中的asmlinkage修饰符是gcc中一个比较特殊的标志。因为gcc常用的一种编译优化方法是使用寄存器传递函数的参数，而加了asmlinkage修饰符的函数必须从堆栈中而不是寄存器中获取参数。内核中所有系统调用的实现都使用了这个修饰符。

####4．重新编译内核

通过以上三个步骤，我们要添加一个新系统调用的所有工作已经完成。但是，要使这个系统调用真正在内核运行起来，我还需要对内核进行重新编译。关于内核的编译，请参阅相关资料。

####5．编写用户态程序

要测试新添加的系统调用，我们可以编写一个用户程序来调用这个系统调用：

```c
/#include<linux/unistd.h>

_syscall0(int,mysyscall) /* unistd.h中对这个宏进行了定义*/

int main()

{

printf(“This is my uid:%d.\n”, getuid());

mysyscall();

printf(“Now , my uid is changed:%d.\n”, getuid());

}
```

上面这个例子是把系统调用直接加入内核，因此，需要重新编译内核。下面的例子是把系统调用以模块的形式加载到内核。

###6.5.2系统调用的调试

添加新的系统调用主要是对内核进行修改并编译。如果在用户态无法成功调用所加系统调用，此时，需判断是系统调用没有加进内核还是用户态的测试程序出现问题。下面给出一种解决方法，也就是将源码中的一部分提出来在用户态进行检测，如果没有添加成功，可以根据返回的错误码进行识别并处理。检测程序如下：

```c
/#include<stdio.h>

/#include<unistd.h>

int main()

{

unsigned long sys_num=333;/*这里的数值是新添加的系统调用的系统调用号*/

unsigned long value=0;

__asm__ ("int $0x80":"=a"(value):"0"((long)(sys_num)));

printf ("The value is %ld\n", value);

return value;

}
```

通过返回值来查看问题所在，如果返回－38则说明没有添加成功，返回－1则说明没有操作的许可权。更多可以查看/usr/include/asm/errno.h

另外，在2.6内核中没有宏syscallN()的定义，它的封装机制由libc库的INLINE_SYSCALL来完成。如果不想在libc库中添加它的封装例程，就需要将syscallN()的宏编译进内核，再在用户态程序以_syscallN()的形式对系统调用进行申明。

##  6.6 实例-系统调用日志收集系统

系统调用是用户程序与系统打交道的唯一入口，因此对系统调用的安全调用直接关系到系统的安全，但对系统管理员来说，某些操作却会给系统管理带来麻烦，比如一个用户恶意地不断调用fork()将导致系统负载增加，所以如果我们能收集到是谁调用了一些有危险的系统调用，以及调用系统调用的时间和其他信息，将有助于系统管理员进行事后追踪，从而提高系统的安全性。。

本实例收集Linux系统运行时系统调用被执行的信息，也就是实时获取系统调用日志，这些日志信息将以可读的形式实时地返回到用户空间，以便做为系统管理或者系统安全分析时的参考数据。

本实例需要完成以下几个基本功能：

第一：记录系统调用日志，将其写入缓冲区（内核中），以便用户读取；

第二：建立新的系统调用，以便将内核缓冲中的系统调用日志返回到用户空间。

第三：循环利用系统调用，以便能动态实时返回系统调用的日志。

### 6.6.1代码结构体系介绍

上面介绍的基本功能对应程序代码中的三个子程序，它们分别是模块中的两个例程
syscall_audit()和mod_sys_audit()以及用户态程序auditd()，以下代码基于2.6.28内核。

#### 1 日志记录例程syscall_audit()

syscall_audit()是一个内核态的服务例程，该例程负责记录系统调用的运行日志，包括调用时刻、调用者PID、程序名等，这些信息可从内核代码的全局变量xtime或current等处获得。实际中，并不是对每一个系统调用信息都进行收集，只需要对系统影响较大的系统调用，比如fork(),clone(),open()等进行收集即可。

为了保证数据连续性，防止丢失，
syscall_audit()建立了一个内核缓冲区存放每刻搜集到的日志数据。当搜集的数据量到达一定阀值时（比如到达缓冲区总大小的%80时），就唤醒系统调用所在进程取回数据。否则继续搜集，这时该例程会堵塞在一个等待队列上，直到被唤醒。

变量的申明和定义如下

```c
/#define COMM_SIZE 16

struct syscall_buf { /*定义缓冲区*/

		u32 serial; /* 序列号 */

		u32 ts_sec; /*秒 */

		u32 ts_micro; /* 微秒 */

		u32 syscall; /* 系统调用号 */

		u32 status; /* 系统调用的状态 */

		pid_t pid; /* 进程标识符 */

		uid_t uid; /* 用户标识符 */

		u8 comm[COMM_SIZE]; /* 进程对应的程序名 */

};

DECLARE_WAIT_QUEUE_HEAD(buffer_wait); /*申明并初始化等待队列buffer_wait
*/

/#define AUDIT_BUF_SIZE 100 /*缓冲区大小 */

static struct syscall_buf audit_buf[AUDIT_BUF_SIZE]; /*缓冲区变量audit_buf
*/

static int current_pos = 0; /*缓冲区中的位置 */

static u32 serial = 0; /*序列号*/
```

代码如下：

```c
void syscall_audit(int syscall,int return_status)

{

		struct syscall_buf *ppb_temp;

		if(current_pos < AUDIT_BUF_SIZE) {

				ppb_temp = &audit_buf[current_pos];

				//以下代码是记录系统调用相关信息

				ppb_temp->serial = serial++;

				ppb_temp->ts_sec = xtime.tv_sec;

				ppb_temp->ts_micro = xtime.tv_usec;

				ppb_temp->syscall = syscall;

				ppb_temp->status=return_status;

				ppb_temp->pid = current->pid;

				ppb_temp->uid = current->uid;

				ppb_temp->euid = current->euid;

				memcpy(ppb_temp->comm, current->comm, COMM_SIZE);

				if (++current_pos == AUDIT_BUF_SIZE*8/10)

				{

						printk("IN MODULE_audit:yes, it near full\n ");

						wake_up_interruptible(&buffer_wait); /*唤醒在等待队列上等待的进程*/

				}

		}
}
```

#### 2 模块例程sys_audit()

由于系统调用是在内核中执行，因此其执行日志也应该在内核态收集。为此，我们需要编写一个模块函数将内核信息带回到用户空间，即sys_audit()，其功能是从缓冲区中取数据返回用户空间。

```c
int sys_audit(u8 type, u8 * us_buf, u16 us_buf_size, u8 reset)

{

		int ret = 0;

		if (!type) {

				if (__clear_user(us_buf, us_buf_size)) { / *清用户态缓冲区*/

						printk("Error:clear_usern");

						return 0;

				}

				printk("IN MODULE_systemcall:starting...\n");

				ret = wait_event_interruptible(buffer_wait,

				current_pos >= AUDIT_BUF_SIZE*8/10);

				printk("IN MODULE_systemcall:over,current_pos is %dn", current_pos);

				if(__copy_to_user(us_buf, audit_buf,

		(current_pos)*sizeof(struct syscall_buf))) { /*将日志拷贝到用户空间*/

						printk("Error:copy error\n");

						return 0;

				}

				ret = current_pos;

				current_pos = 0; /*清空缓冲区*/

		}

		return ret;

}
```

当收集的日志数量达到缓冲区总容量的80％时，则调用wait_event_interruptible()让进程在buffer_wait等待队列上等待。否则，调用__copy_to_user()把缓冲区当前位置中的日志信息拷贝到用户空间的缓冲区。最后，返回缓冲区的当前位置。

#### 3 模块的初始化和退出

为了在模块中能对syscall_audit()和sys_audit()函数动态加载和卸载，我们又定义了与这两个函数对应的钩子函数my_audit（）和my_sysaudit（）；它们的定义在另一个文件中（参见6.6.2节），于是在模块中，申明它们为外部函数。

extern void (*my_audit)(int ,int );

extern int (*my_sysaudit)(unsigned char,unsigned char*,unsigned
short,unsigned char);

于是，模块的初始化函数如下：

```c
static int __init audit_init(void)

{

		my_sysaudit = sys_audit;

		my_audit = syscall_audit;

		printk("Starting System Call Auditing\n");

		return 0;

}
```

模块的退出函数如下：

```c
static void __exit audit_exit(void)

{

		my_audit = NULL;

		my_sysaudit = NULL;

		printk("Exiting System Call Auditing\n");

		return ;

}
```

#### 4 用户空间收集日志进程auditd 

我们需要一个用户空间进程来不断的调用audit()系统调用，取回系统中搜集到的系统调用日志信息。这里要说明的是，连续不断地调用日志序列对于分析入侵或系统行为等才有价值。

```c
/#include<stdlib.h>

/#include<stdio.h>

/#include<errno.h>

/#include<signal.h>

/#include<unistd.h>

/#include<sys/resource.h>

/#include<sys/syscall.h>

/#include "types.h" /*包含struct syscall_buf的定义*/

/#define AUDIT_BUF_SIZE 100*sizeof(struct syscall_buf)

int main(int argc, char *argv[])

{

		u8 col_buf[AUDIT_BUF_SIZE];

		unsigned char reset =1;

		int num = 0;

		struct syscall_buf *p;

		while (1) {

				num = syscall(__NR_myaudit, 0, col_buf, AUDIT_BUF_SIZE, reset);

				printf("num:%d\n", num);

				u8 j=0;

				int i;

				p = (struct syscall_buf *)col_buf;

				for (i = 0;i < num;i++) {

						printf("num [%d],serial: %d\t", i, p[i].serial);

						printf("syscall: %d\n", p[i].syscall);

						printf("ts_sec: %d\n", ((struct syscall_buf*)col_buf)[i].ts_sec);

						printf("status: %d\n", ((struct syscall_buf*)col_buf)[i].status);

						printf("pid: %d\n", ((struct syscall_buf*)col_buf)[i].pid);

						printf("uid: %d\n", ((struct syscall_buf*)col_buf)[i].uid);

						printf("comm: %s\n", ((struct syscall_buf*)col_buf)[i].comm);

				}

		}

		return 1;

}
```

<div style="text-align: center">
<img src="media/14.png"/>
</div>

<center>图6.2 日志收集系统的代码结构</center>
### 6.6.2把代码集成到内核中

除了上面介绍的内容外，还需要一些辅助性的工作，这些工作将帮助我们将上述代码灵活地结成一体，以完成需要的功能。

####1. 添加系统调用号

与6.5节中添加系统调用的步骤一样，首先修改arch/x86/include/asm/unistd_32.h和/usr/include/asm/unistd_32.h文件，如下：

/#definle _NR_mysyscall 333

/#define __NR_myaudit 334

####2. 在系统调用表中添加相应表项

arch/x86/kernel/syscall_table_32.S文件中含有系统调用表，在其中加入新的系统调用如下：

ENTRY(sys_call_table)

.long sys_restart_syscall /* 0 - old "setup()" system call, used for
restarting */

.long sys_exit

.long sys_fork

.long sys_read

…

long sys_mysyscall /*333号*/

.long sys_myaudit /*334号*/

####3. 修改系统调用入口

在arch/x86/kernel/entry_32.S中含有系统调用入口system_call，因此在该文件中添加如下代码：

syscall_call:

call *sys_call_table(,%eax,4)

movl %eax,PT_EAX(%esp) /# store the return value

/#以下代码为新添加代码

cmpl $2, 0x28(%esp) /# this is fork()

je myauditsys

cmpl $5, 0x28(%esp) /# this is open()

je myauditsys

cmpl $6, 0x28(%esp) /# this is close()

je myauditsys

cmpl $11, 0x28(%esp) /# this is execv()

je myauditsys

cmpl $20, 0x28(%esp) /# this is getpid()

je myauditsys

cmpl $120, 0x28(%esp) /# this is clone()

je myauditsys

/#添加代码段结束

以上代码保证在每次系统调用后都执行比较，如果系统调用号与我们要收集的系统调用号系统，则将调用myauditsys代码段，如下代码：

syscall_exit:

……

/#以下为新添加代码段

jmp restore_all /#new add

myauditsys:

pushl %eax /# pass in return status

CFI_ADJUST_CFA_OFFSET 4 /# help to debug

pushl 0x2C(%esp) /# pass in syscall number

CFI_ADJUST_CFA_OFFSET 4

call syscall_audit;

popl %eax /# remove orig_eax from stack

popl %eax /# remove eax from stack

jmp syscall_exit

/#新添加代码段结束

restore_all:

movl PT_EFLAGS(%esp), %eax /# mix EFLAGS, SS and CS

其中调用了我们编写的日志记录例程syscall_audit()。

####4. 添加自己的文件

在/arch/x86/kernel/目录下添加自己编写的myaudit.c文件，该文件包含的内容如下：

```c
/#include<asm/uaccess.h>

/#include<linux/proc_fs.h>

/#include<linux/init.h>

/#include<linux/types.h>

/#include<asm/current.h>

/#include<linux/sched.h>

void (*my_audit)(int, int) = 0;

/* 系统调用日志记录例程 */

asmlinkage void syscall_audit(int syscall,int return_status)

{

		if(my_audit)

		return (*my_audit)(syscall, return_status);

		printk("IN KERNEL:%s(%d),syscall:%d,return:%d\n",

		current->comm, current->pid, syscall, return_status);

		return ;

}

/* 系统调用 */

int (*my_sysaudit)(u8,u8*,u16,u8)=0;

asmlinkage int sys_myaudit(u8 type, u8 * us_buf, u16 us_buf_size, u8 reset)

{

		if(my_sysaudit)

		return (*my_sysaudit)(type,us_buf,us_buf_size,reset);

		printk("IN KERNEL:my system call sys_myaudit() working\n");

		return 1;

}
```

从代码可以看出sycall_audit()和sys_audit()并没有实现而是用两个钩子函数my_audit()和my_sysaudit()作为替身。而这两个钩子函数my_audit()和my_sysaudit()被放在模块中去实现，这样可以动态加载，方便调式。代码的结构如图6.2所示：

####5. 修改Makefile文件

修改arch/x86/kernel/Makefile:

加入 obj-y +=audit.o，即告诉内核将模块audit.o编译进内核

####6. 导出函数名，以提供内核接口函数

修改arch/x86/kernel/i386_ksyms_32.c，在末尾加入：

extern void (*my_audit)(int,int);

EXPORT_SYMBOL(my_audit);

extern int(*my_sysaudit)(unsigned char,unsigned char*unsigned short,unsigned
char);

EXPORT_SYMBOL (my_sysaudit);

通过EXPORT_SYMBOL导出刚加入的函数名，以便其他内核函数调用，这两个钩子函数的实现我们放在了模块中。

####7. 编译并加载模块

insmod audit.o

####8 重新编译内核

##6.7 本章小结

系统调用是内核与用户程序进行交互的接口。本章从不同角度对系统调用进行了描述，说明了系统调用与API、系统命令以及内核函数之间的关系。然后，我们分析了Linux内核如何实现系统调用，说明系统调用处理程序以及服务例程在整个系统调用执行过程中的作用。

最后，通过两个实例讨论了如何增加系统调用，并给出了从用户空间调用系统调用的简单例子。增加一个系统调用并不难，它有一套比较规范的方法，难点是在实际应用中如何增加合适的系统调用，本章最后一个例子日志收集系统给出完整的过程，以便读者充分认识系统调用的价值并在自己的项目开发中灵活应用。

1.  什么是系统调用，为什么要引入系统调用？

2.  系统调用与库函数、系统命令及内核函数有什么区别和联系？

3.  内核为什么要设置系统调用处理程序，它与服务例程有什么区别？

4.  system_call()函数为什么要把当前进程的PCB地址保存在ebx寄存器中？

5.  画出system_call()的流程图。

6.  说明系统调用号的作用？

7.  画出系统调用进入内核时内核态堆栈的内容。

8.  用KDB跟踪一个系统调用（如read()）的执行过程，然后给出执行路径。

9.  如何封装系统调用？

10. 参照write()系统调用，写出read()系统调用的汇编代码。

11. 给出添加一个系统调用的步骤。

12. 编写一个新的系统调用，并进行调试。

13. 调试日志收集系统，给出调试过程和体会。
